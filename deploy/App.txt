<!DOCTYPE html>
<html>
<head>
    <title>Story Rollup Custom List</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Mon Aug 08 2016 14:02:55 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Aug 08 2016 14:02:55 GMT-0600 (MDT)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 69263260899;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CArABU.technicalservices.chunk.Store',{

    MAX_CHUNK_SIZE: 25,
    logger: new Rally.technicalservices.Logger(),

    constructor: function(config) {
        this.chunkProperty = config.chunkProperty;
        this.chunkValue = config.chunkValue;

        this.storeConfig = config.storeConfig || {};
        this.storeType = config.storeType || 'Rally.data.wsapi.Store';

    },
    load: function(){
        var deferred = Ext.create('Deft.Deferred');

        var promises = [],
            chunkArray = this.chunkValue,
            config = this.storeConfig;

        for (var i=0; i < chunkArray.length; i = i+this.MAX_CHUNK_SIZE){
            var chunk = Ext.Array.slice(chunkArray, i, i + this.MAX_CHUNK_SIZE);
            promises.push(this._fetchChunk(chunk, config));
        }

        Deft.Promise.all(promises).then({
            success: function(results){
                var records = _.flatten(results);
                this.logger.log('load SUCCESS results', results,records);
                deferred.resolve(records);
            },
            failure: function(msg){
                this.logger.log('load FAILURE', chunkArray, msg);
                deferred.reject(msg);
            },
            scope: this
        });


        return deferred;
    },

    _fetchChunk: function(objectIDs, config){
        this.logger.log('chunk.Store._fetchChunk',objectIDs, config);
        var deferred = Ext.create('Deft.Deferred');

        var chunkProperty = this.chunkProperty,
            filters = _.map(objectIDs, function(o){ return {
                property: chunkProperty,
                value: o
            }
        });
        filters = Rally.data.wsapi.Filter.or(filters);


        if (config.filters){
            if (Ext.isArray(config.filters)){
                config.filters  = Rally.data.wsapi.Filter.and(config.filters);
            }
            filters = filters.and(config.filters);
        }
        this.logger.log('chunk.Store._fetchChunk',filters.toString());

        var fetch = config.fetch || true,
            model = config.model || 'HierarchicalRequirement';

        Ext.create(this.storeType,{
            fetch: fetch,
            filters: filters,
            model: model,
            context: {project: null}
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    var msg = "Failure loading records for objectIDs: " + objectIDs.join(', ') + ":  " + operation.error.errors.join(',');
                    deferred.resolve(msg);
                }
            }
        });
        return deferred;
    }

});
Ext.override(Rally.data.wsapi.TreeStore,{
    _decorateModels: function() {
        var models = this.model;

        if (_.isFunction(models.getArtifactComponentModels)) {
            models = models.getArtifactComponentModels();
        }

        Ext.Array.each(models, function(m){
            if (m.typePath === "hierarchicalrequirement"){
                m.addField({name: 'PercentDoneByStoryCount', type: 'auto', defaultValue: null, modelType: 'hierarchicalrequirement'});
                m.addField({name: 'PercentDoneByStoryPlanEstimate', type: 'auto', defaultValue: null, modelType: 'hierarchicalrequirement'});
            }
            m.addField({name: 'Teams', type: 'auto', defaultValue: null});
        });

        _.each(Ext.Array.from(models), Rally.ui.grid.data.NodeInterface.decorate, Rally.ui.grid.data.NodeInterface);
    }
});

Ext.override(Rally.ui.grid.TreeGrid, {
    _mergeColumnConfigs: function(newColumns, oldColumns) {

        var mergedColumns= _.map(newColumns, function(newColumn) {
            var oldColumn = _.find(oldColumns, {dataIndex: this._getColumnName(newColumn)});
            if (oldColumn) {
                return this._getColumnConfigFromColumn(oldColumn);
            }

            return newColumn;
        }, this);
        mergedColumns = mergedColumns.concat(this.config.derivedColumns);
        return mergedColumns;
    },
    _getColumnConfigsBasedOnCurrentOrder: function(columnConfigs) {
        var cols = _(this.headerCt.items.getRange()).map(function(column) {
            //override:  Added additional search for column.text
            return _.contains(columnConfigs, column.dataIndex) ? column.dataIndex : _.find(columnConfigs, {xtype: column.xtype, text: column.text });
        }).compact().value();

        return cols;
    },
    _restoreColumnOrder: function(columnConfigs) {

        var currentColumns = this._getColumnConfigsBasedOnCurrentOrder(columnConfigs);
        var addedColumns = _.filter(columnConfigs, function(config) {
            return !_.find(currentColumns, {dataIndex: config.dataIndex}) || Ext.isString(config);
        });
        return currentColumns.concat(addedColumns);
    },
    _applyStatefulColumns: function(columns) {
        if (this.alwaysShowDefaultColumns) {
            _.each(this.columnCfgs, function(columnCfg) {
                if (!_.any(columns, {dataIndex: this._getColumnName(columnCfg)})) {
                    columns.push(columnCfg);
                }
            }, this);
        }

        if (this.config && this.config.derivedColumns){
            this.columnCfgs = columns.concat(this.config.derivedColumns);
        } else {
            this.columnCfgs = columns;
        }

    }
});

Ext.override(Rally.ui.renderer.RendererFactory, {

    typeFieldTemplates: {
        defectsuite: {
            state: function(field) {
                return Ext.create('Rally.ui.renderer.template.DefectSuiteStateTemplate', {
                    field: field
                });
            }
        },
        milestone: {
            formattedid: function(field) {
                return Ext.create('Rally.ui.renderer.template.FormattedIDTemplate');
            }
        },
        task: {
            state: function(field) {
                return Ext.create('Rally.ui.renderer.template.ScheduleStateTemplate', {
                    field: field,
                    showTrigger: true
                });
            }
        },
        testcase: {
            lastbuild: function(field) {
                return Ext.create('Rally.ui.renderer.template.LastBuildTemplate');
            }
        },
        recyclebinentry: {
            type: function(field) {
                return Ext.create('Rally.ui.renderer.template.TypeDefNameTemplate', {
                    fieldName: field.name
                });
            }
        },
        hierarchicalrequirement: {
            percentdonebystorycount: function(field){
                return Ext.create('Rally.ui.renderer.template.progressbar.StoryPercentDoneByStoryCountTemplate',{
                    startDateField: CArABU.technicalservices.StoryRollupCustomListSettings.storyStartDateField,
                    endDateField: CArABU.technicalservices.StoryRollupCustomListSettings.storyEndDateField
                });
            },
            percentdonebystoryplanestimate: function(field){
                return Ext.create('Rally.ui.renderer.template.progressbar.StoryPercentDoneByStoryPlanEstimateTemplate',{
                    startDateField: CArABU.technicalservices.StoryRollupCustomListSettings.storyStartDateField,
                    endDateField: CArABU.technicalservices.StoryRollupCustomListSettings.storyEndDateField
                });
            }
        }
    }

});
Ext.define('Rally.ui.renderer.template.progressbar.StoryPercentDoneTemplate', {
    requires: [
        'Rally.util.HealthColorCalculator'
    ],
    extend: 'Rally.ui.renderer.template.progressbar.ProgressBarTemplate',

    config: {
        calculateColorFn: function(recordData) {
            var colorObject = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(recordData, this.percentDoneName);
            return colorObject.hex;
        },
        isClickable: true
    },

    constructor: function(config) {
        this.initConfig(config);
        return this.callParent(arguments);
    }
});

/**
 * The Ext.XTemplate used to render the percent done component and column in the grid.
 */
Ext.define('Rally.ui.renderer.template.progressbar.StoryPercentDoneByStoryPlanEstimateTemplate', {
    requires: [],
    extend: 'Rally.ui.renderer.template.progressbar.StoryPercentDoneTemplate',

    config: {
        /**
         * @cfg {String}
         * define a height if necessary to fit where it's being used
         */
        height:'15px',
        /**
         * @cfg {String}
         * sometimes it's necessary to name the variable used as the percent done replacement in the template,
         * like in a grid when a record is used to render the template.
         */
        percentDoneName: 'PercentDoneByStoryPlanEstimate',
        /**
         * @cfg {Function}
         * A function that should return true to show a triangle in the top right to denote something is missing.
         * Defaults to:
         *      function(){ return false; }
         */
        showDangerNotificationFn:function (recordData) {
            return !recordData.PlanEstimate;  //(!recordData.PlannedEndDate && !recordData.ActualEndDate) || recordData.UnEstimatedLeafStoryCount > 0;
        },

        /**
         * @cfg {Boolean}
         * If the percent done is 0%, do not show the bar at all
         */
        showOnlyIfInProgress: false
    },

    constructor: function(config) {
        this.initConfig(config);
        return this.callParent(arguments);
    }
});

Ext.define('Rally.ui.renderer.template.progressbar.StoryPercentDoneByStoryCountTemplate', {
    requires: [],
    extend: 'Rally.ui.renderer.template.progressbar.StoryPercentDoneTemplate',

    config: {
        /**
         * @cfg {String}
         * define a height if necessary to fit where it's being used
         */
        height:'15px',
        /**
         * @cfg {String}
         * sometimes it's necessary to name the variable used as the percent done replacement in the template,
         * like in a grid when a record is used to render the template.
         */
        percentDoneName: 'PercentDoneByStoryCount',
        /**
         * @cfg {Function}
         * A function that should return true to show a triangle in the top right to denote something is missing.
         * Defaults to:
         *      function(){ return false; }
         */
        showDangerNotificationFn: function (recordData) {
            return !this.startDateField || !recordData[this.startDateField] ||
                !this.endDateField || !recordData[this.endDateField];
        },

        /**
         * @cfg {Boolean}
         * If the percent done is 0%, do not show the bar at all
         */
        showOnlyIfInProgress: false
    },

    constructor: function(config) {
        this.initConfig(config);
        return this.callParent(arguments);
    }
});
(function() {
    var Ext = window.Ext4 || window.Ext;

    var getDate = function(dateString){
        return Ext.Date.parse(dateString,'c') || new Date(Date.parse(dateString));
    };

    var formatDate = function(dateString) {
        var date = getDate(dateString);
        return Rally.util.DateTime.formatWithDefault(date);
    };

    var getAcceptedTpl = _.memoize(function() {
        return Ext.create('Ext.XTemplate',
            '<h3>% DONE</h3>',
            '<div class="percentDoneLine">',
            '{[this.renderPercentDoneByStoryPlanEstimate(values)]}',
            '<div class="percentDoneText">{AcceptedLeafStoryPlanEstimateTotal} of {LeafStoryPlanEstimateTotal} Points Accepted</div>',
            '</div>',
            '<div class="percentDoneLine">',
            '{[this.renderPercentDoneByStoryCount(values)]}',
            '<div class="percentDoneText">{AcceptedLeafStoryCount} of {LeafStoryCount} User Stories Accepted</div>',
            '</div>',
            '<tpl if="UnEstimatedLeafStoryCount &gt; 0">',
            '<div class="dangerNotification percentDoneLine">',
            'Missing Estimates: ',
            '<div><b>{UnEstimatedLeafStoryCount} User Stor{[values.UnEstimatedLeafStoryCount == 1? "y" : "ies"]}</b></div>',
            '</div>',
            '</tpl>',
            '<tpl if="!PlannedEndDate && !ActualEndDate">',
            '<div class="dangerNotification percentDoneLine">Missing Planned End Date</div>',
            '</tpl>', {
                renderPercentDoneByStoryPlanEstimate: function(recordData) {
                    return Ext.create('Rally.ui.renderer.template.progressbar.PortfolioItemPercentDoneTemplate', {
                        percentDoneName: 'PercentDoneByStoryPlanEstimate',
                        height: '15px',
                        width: '50px',
                        isClickable: false
                    }).apply(recordData);
                },
                renderPercentDoneByStoryCount: function(recordData) {
                    return Ext.create('Rally.ui.renderer.template.progressbar.PortfolioItemPercentDoneTemplate', {
                        percentDoneName: 'PercentDoneByStoryCount',
                        height: '15px',
                        width: '50px',
                        isClickable: false
                    }).apply(recordData);
                }
            });
    });

    var getActualEndDateTpl = _.memoize(function() {
        return Ext.create('Ext.XTemplate',
            '<hr/>',
            '<h3>ACTUAL END DATE</h3>',
            '<div class="actualEndDateInfo percentDoneLine">',
            '{[this.formatDate(values.ActualEndDate)]}',
            '<tpl if="PlannedEndDate">',
            ' ({[this.getEstimateMessage(values)]})',
            '</tpl></div>', {
                getEstimateMessage: _.bind(function(values) {
                    var message;

                    var actualEnd = getDate(values.ActualEndDate);
                    var plannedEnd = getDate(values.PlannedEndDate);

                    var diff = Rally.util.DateTime.getDifference(plannedEnd, actualEnd, 'day');
                    if (diff === 0) {
                        message = 'on time';
                    } else if (diff > 0) {
                        message = diff + ' day' + (diff === 1 ? '' : 's') + ' early';
                    } else {
                        diff = Math.abs(diff);
                        message = diff + ' day' + (diff === 1 ? '' : 's') + ' late';
                    }

                    return message;
                }, this),
                formatDate: formatDate
            });
    });

    var getNotesTpl = _.memoize(function() {
        return Ext.create('Ext.XTemplate',
            '<hr/>',
            '<h3>NOTES</h3>',
            '<div class="percentDoneLine">{Notes}</div>');
    });

    var getReleaseTpl = _.memoize(function() {
        return Ext.create('Ext.XTemplate',
            '<hr/>',
            '<h3>{Release.Name} ({[this.formatDate(values.Release.ReleaseStartDate)]} - {[this.formatDate(values.Release.ReleaseDate)]})</h3>',
            '<tpl if="this.shouldShowPlannedEndDateAlert(values)">',
            '<tpl if="this.showUpdateText(values)">',
            '<div class="dangerNotification percentDoneLine">{PortfolioItemTypeName} Planned End Date:',
            '<div>',
            '<b>{[this.formatDate(values.PlannedEndDate)]}</b> ',
            '<tpl if="values.canUpdate">',
            '<a class="update-link">Update to {[this.formatDate(values.Release.ReleaseDate)]}</a>',
            '</tpl>',
            '</div>',
            '</div>',
            '</tpl>',
            '<tpl if="this.showViewText(values)">',
            '<div class="dangerNotification percentDoneLine">' +
            '{PortfolioItemTypeName} Planned Start &amp; End Dates ',
            '({[this.formatDate(values.PlannedStartDate)]} - {[this.formatDate(values.PlannedEndDate)]}) exist',
            ' outside of the Release End Date.',
            '<tpl if="values.canUpdate">',
            '<a class="detail-link">View</a>',
            '</tpl>',
            '</div>',
            '</tpl>',
            '</tpl>',
            {
                formatDate: formatDate,
                showUpdateText: function(percentDoneData) {
                    var start = percentDoneData.PlannedStartDate;
                    return !start || getDate(start) <= getDate(percentDoneData.Release.ReleaseDate);
                },
                showViewText: function(percentDoneData) {
                    return !this.showUpdateText(percentDoneData);
                },
                shouldShowPlannedEndDateAlert: function(percentDoneData) {
                    return percentDoneData.instance._shouldShowReleaseSection(percentDoneData);
                }
            }
        );
    });

    var getLateChildTpl = _.memoize(function() {
        return Ext.create('Ext.XTemplate',
            '<tpl if="this.shouldShowLateChildAlert(values)">',
            '<div class="dangerNotification percentDoneLine">' +
            'Assigned to later releases or iterations:',
            '<div>',
            '<b>{LateChildCount} {[this.getUserStoriesText(values.LateChildCount)]}</b> ',
            '<a class="late-story-view-link">View</a>',
            '</div>',
            '</div>',
            '</tpl>',
            {
                getUserStoriesText: function(lateChildCount){
                    return lateChildCount > 1 ? 'User Stories' : 'User Story';
                },
                shouldShowLateChildAlert: function(percentDoneData) {
                    return percentDoneData.instance._shouldShowLateChildAlert(percentDoneData);
                }
            });
    });

    /**
     * A Rally.ui.popover.Popover extended to show data about a Portfolio Item's percent done.
     * It's expected to be used in 2 ways, by passing in the data at initialization time, or at show time so the Popover can be reused.
     *
     * The first way:
     *
     *      Ext.create('Rally.ui.popover.PercentDonePopover', {
     *          target: targetEl, //the element, or id, that the popover displays for when it's clicked
     *          percentDoneData: {
     *              ActualEndDate: 'Thu Nov 10 00:00:00 MST 2011',
     *              PlannedEndDate: 'Thu Nov 12 00:00:00 MST 2011',
     *              //... other data
     *          }
     *      });
     *
     *
     * The second way:
     *
     *      var pop = Ext.create('Rally.ui.popover.PercentDonePopover', {
     *          target: Ext.getBody(),
     *          delegate: '.mySelectorForAllTargets'
     *      }
     *
     *      //attach to 'beforeshow' to update at some later time
     *      pop.on('beforeshow', function(){
     *
     *          pop.updateContent({
     *              ActualEndDate: 'Thu Nov 10 00:00:00 MST 2011',
     *              PlannedEndDate: 'Thu Nov 12 00:00:00 MST 2011',
     *              //... other data
     *          });
     *
     *          //or just give it a record's data:
     *          pop.updateContent(record.data);
     *      });
     *
     *  It can also be created via Rally.ui.popover.PopoverFactory#bake:
     *
     *     Rally.ui.popover.PopoverFactory.bake({
     *         field: 'PercentDoneByStoryCount' //or 'PercentDoneByPlanEstimate'
     *     });
     */
    Ext.define('Rally.ui.popover.PercentDonePopover', {
        extend: 'Rally.ui.popover.Popover',

        mixins: [
            'Rally.Messageable'
        ],

        clientMetrics: [
            {
                method: '_onClickUpdatePlannedEndDate',
                description: 'clicked to update planned end date from ' + window.location.href
            },
            {
                beginMethod: '_onClickUpdatePlannedEndDate',
                endMethod: '_onPlannedEndDateUpdated',
                description: 'updated planned end date'
            }
        ],

        config: {
            /**
             * @cfg {Object} percentDoneData (optional) data to use for the Popover.
             * Optional to define it when created, can be passed to updateContent directly if you need to handle it later.
             * @cfg {Number} percentDoneData.PercentDoneByStoryPlanEstimate
             * @cfg {Number} percentDoneData.PercentDoneByStoryCount
             * @cfg {String/Date} percentDoneData.ActualEndDate
             * @cfg {String/Date} percentDoneData.PlannedStartDate
             * @cfg {String/Date} percentDoneData.PlannedEndDate
             * @cfg {Number} percentDoneData.AcceptedLeafStoryPlanEstimateTotal
             * @cfg {Number} percentDoneData.LeafStoryPlanEstimateTotal
             * @cfg {Number} percentDoneData.AcceptedLeafStoryCount
             * @cfg {Number} percentDoneData.LeafStoryCount
             * @cfg {Number} percentDoneData.UnEstimatedLeafStoryCount
             * @cfg {String} percentDoneData.Notes
             */
            percentDoneData: {
                PercentDoneByStoryPlanEstimate: 0,
                PercentDoneByStoryCount: 0,
                ActualEndDate: undefined,
                PlannedStartDate: undefined,
                PlannedEndDate: undefined,
                AcceptedLeafStoryPlanEstimateTotal: 0,
                LeafStoryPlanEstimateTotal: 0,
                AcceptedLeafStoryCount: 0,
                LeafStoryCount: 0,
                UnEstimatedLeafStoryCount: 0,
                Notes: undefined,
                PortfolioItemTypeOrdinal: undefined,
                LateChildCount: 0
            },

            /**
             * @cfg {Boolean} canUpdate (optional)
             * Indicates if the user can update the portfolio item
             */
            canUpdate: false,

            /**
             * @cfg {Boolean} legacyPage (optional)
             * Indicates if the request is originating from a legacy page
             */
            legacyPage: false,

            /**
             * @cfg {Number} oid (optional)
             * Object ID of the portfolio item
             */
            oid:null,

            /**
             * @cfg {String} piRef (optional)
             * _ref url of the portfolio item
             */
            piRef:null,

            /**
             * @cfg {String} percentDoneName (required)
             * The name of the field to use to show the status for.
             * Necessary because the PI might be "On Track" when considering stories completed,
             * but "Late" if considering the plan estimates of stories completed and not completed.
             */
            percentDoneName: 'PercentDoneByStoryCount',

            width:320,
            manageHeight:false
        },

        id: 'percentDonePopover',
        cls: 'percentDonePopover',

        constructor: function(config) {
            this.id += Ext.Date.now().toString();
            if (!Ext.getElementById(this.id)) {
                this.initConfig(config);
                config.items = {
                    itemId: 'percentDonePopoverContent',
                    xtype: 'component',
                    html: this._buildContent(this.config.percentDoneData),
                    listeners: {
                        afterrender: function() {
                            if (!this._hasReleaseData(this.config.percentDoneData)){
                                this._retrievePortfolioItemType();
                            } else {
                                this._setTitle();
                                this._attachActions();
                                if (Rally.BrowserTest) {
                                    Rally.BrowserTest.publishComponentReady(this);
                                }
                            }
                        },
                        scope: this
                    }
                };

                this.callParent(arguments);
            }
        },

        /**
         * Update the Popover with new data.
         * Takes the same options that the percentDoneData config option accepts. Matches the Names of fields on Portfolio Item records
         * so you can just pass in record.data to update.
         * @param {Object} percentDoneData (optional)
         * @param {String/Date} percentDoneData.ActualEndDate
         * @param {String/Date} percentDoneData.PlannedEndDate
         * @param {Number} percentDoneData.AcceptedLeafStoryPlanEstimateTotal
         * @param {Number} percentDoneData.LeafStoryPlanEstimateTotal
         * @param {Number} percentDoneData.AcceptedLeafStoryCount
         * @param {Number} percentDoneData.LeafStoryCount
         * @param {Number} percentDoneData.UnEstimatedLeafStoryCount
         * @param {String} percentDoneData.Notes
         * @param {Object} percentDoneData.Release
         * @param {Number} percentDoneData.PortfolioItemTypeOrdinal
         */
        updateContent: function(percentDoneData) {
            var popoverContent = this.down('#percentDonePopoverContent');

            if (popoverContent) {
                this.config.percentDoneData = Ext.applyIf(percentDoneData || {}, this.config.percentDoneData);
                var content = this._buildContent(this.config.percentDoneData);
                popoverContent.update(content);
                this._setTitle();
                this._attachActions();
            }
        },

        _setTitle: function() {
            this.setTitle(Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(this.config.percentDoneData,
                this.getPercentDoneName()).label);
        },

        _buildContent: function(percentDoneData) {
            var html = '';
            percentDoneData.instance = this;
            percentDoneData.canUpdate = this.config.canUpdate;

            html += '<div class="percentDoneContainer">';

            html += getAcceptedTpl().apply(percentDoneData);

            if (!Ext.isEmpty(percentDoneData.ActualEndDate)) {
                html += getActualEndDateTpl().apply(percentDoneData);
            }

            //ajax request
            if(this._shouldShowReleaseSection(percentDoneData)) {
                html += getReleaseTpl().apply(percentDoneData);

                if(this._shouldShowLateChildAlert(percentDoneData)) {
                    html += getLateChildTpl().apply(percentDoneData);
                }
            }

            if (this._shouldShowNotes(percentDoneData)) {
                html += getNotesTpl().apply(percentDoneData);
            }

            html += '</div>';

            return html;
        },

        _releaseQueried:false,

        _retrievePortfolioItemType: function(){
            Ext.create("Rally.data.wsapi.Store",{
                autoLoad: true,
                model: Ext.identityFn('TypeDefinition'),
                filters: [
                    {
                        property: 'Parent.Name',
                        operator: '=',
                        value: 'Portfolio Item'
                    },
                    {
                        property: 'Ordinal',
                        operator: '=',
                        value: '0'
                    }
                ],
                listeners:{
                    load: this._onPortfolioItemTypeRetrieved,
                    scope:this
                }
            });
        },

        _onPortfolioItemTypeRetrieved: function(typeDefStore){
            var record = typeDefStore.getAt(0).data;
            this.config.percentDoneData.PortfolioItemTypeOrdinal = record.Ordinal;
            this.config.percentDoneData.PortfolioItemTypeName = record.Name;
            this._retrieveReleaseData(record.TypePath);
        },

        _retrieveReleaseData: function(typePath){
            var fetchFields = ["Release", "ReleaseDate", "ReleaseStartDate", "Name", "PlannedStartDate", "PlannedEndDate", "LateChildCount"];
            if (!Ext.isString(this.config.percentDoneData.Notes)) {
                fetchFields.push('Notes');
            }
            this.store = Ext.create("Rally.data.wsapi.Store", {
                model: typePath,
                fetch: fetchFields,
                filters: [
                    {
                        property: "ObjectID",
                        operator: "=",
                        value: this.config.oid || Rally.util.Ref.getOidFromRef(this.config.piRef)
                    }
                ],
                autoLoad: true,
                listeners: {
                    load: this._onReleaseDataRetrieved,
                    scope: this
                }
            });
        },

        _onReleaseDataRetrieved: function(store){
            var record = store.getAt(0);
            this._releaseQueried = true;
            if (record){
                this.config.percentDoneData.Release = record.data.Release;
                this.config.percentDoneData.PlannedStartDate = record.data.PlannedStartDate;
                this.config.percentDoneData.PlannedEndDate = record.data.PlannedEndDate;
                this.config.percentDoneData.LateChildCount = record.data.LateChildCount;
                this.config.canUpdate = record.self.getPermissionLevels(record.data._p).updatable;
                if (!Ext.isString(this.config.percentDoneData.Notes)) {
                    this.config.percentDoneData.Notes = record.data.Notes;
                }
                this.updateContent({
                    Release: record.data.Release
                });
            }else{
                this.updateContent();
            }

            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _attachActions: function(){
            this.getEl().select('a.update-link').on('click', this._onClickUpdatePlannedEndDate, this);
            this.getEl().select('a.detail-link').on('click', this._onClickViewDetail, this);
            this.getEl().select('a.late-story-view-link').on('click', this._onClickLateStories, this);
        },

        _onClickUpdatePlannedEndDate: function(evt, el){
            Ext.get(el)
                .removeAllListeners()
                .setStyle({
                    color:'gray',
                    cursor:'default'
                })
                .update(el.innerHTML.replace('Update','Updating') + '...');

            var record = this.store.getAt(0);
            record.set('PlannedEndDate',record.data.Release.ReleaseDate);
            record.save({
                success: this._onPlannedEndDateUpdated,
                scope: this
            });
        },

        _onClickViewDetail: function(){
            var data = this.store.getAt(0);
            this.destroy();
            window.location = Rally.nav.Manager.getDetailUrl(data);
        },

        _onClickLateStories: function() {
            var record = this.store.getAt(0),
                filters = this._filterPopover(record.data),
                target = this.target,
                targetSelector = this.targetSelector;

            //  Close the % done popover
            this.destroy();

            //  Open the new popover
            var reloadStoreCallback;
            Rally.ui.popover.PopoverFactory.bake({
                target: target,
                targetSelector: targetSelector,
                record: record,
                field: 'UserStory',
                autoShow: false,
                title: 'User Stories Assigned to Later Releases or Iteration',
                items: [{
                    gridConfig: {
                        storeConfig: {
                            filters: filters
                        },
                        listeners: {
                            viewready: function(grid) {
                                reloadStoreCallback = _.bind(this._reloadStore, this, grid);
                                this.subscribe(Rally.Message.recordUpdateSuccess, reloadStoreCallback);
                            },
                            destroy: function(grid) {
                                this.unsubscribe(Rally.Message.recordUpdateSuccess, reloadStoreCallback);
                            },
                            scope: this
                        }
                    }
                }]
            }).show();
        },

        _filterPopover: function(record) {
            return [
                {
                    property: 'Feature',
                    operator: '=',
                    value: record._ref
                },
                {
                    property: 'DirectChildrenCount',
                    operator: '=',
                    value: 0
                },
                Rally.data.wsapi.Filter.or([
                    {
                        property: 'Iteration.EndDate',
                        operator: '>',
                        value: record.Release.ReleaseDate
                    },
                    {
                        property: 'Release.ReleaseDate',
                        operator: '>',
                        value: record.Release.ReleaseDate
                    }
                ])
            ];
        },

        _onPlannedEndDateUpdated: function(record) {
            if (this.config.legacyPage) {
                this.publish(Rally.app.Message.legacyPageRefreshRequest);
            }
            this.publish(Rally.Message.objectUpdate, record, ['PlannedEndDate'], this);
            this.publish(Rally.Message.recordUpdateSuccess, record);
            this.updateContent({PlannedEndDate:record.data.PlannedEndDate});
        },

        _hasReleaseData: function(data){
            return this._releaseQueried ||
                (Ext.isObject(data.Release) && Ext.isNumber(data.PortfolioItemTypeOrdinal) && Ext.isString(data.Notes));
        },

        _shouldShowNotes: function(data){
            return this._hasReleaseData(data) && !Ext.isEmpty(data.Notes);
        },

        _shouldShowReleaseSection: function(data){
            return this._hasReleaseData(data) &&
                Ext.isObject(data.Release) &&
                data.Release.ReleaseDate &&
                data.PortfolioItemTypeOrdinal === 0 && //is feature
                data.PlannedEndDate && //has planned end date
                getDate(data.Release.ReleaseDate.toString()) < getDate(data.PlannedEndDate.toString()); // release end date < planned end date
        },

        _shouldShowLateChildAlert: function (data){
            return data.LateChildCount > 0;
        },

        // We manually adjust the editing plugin to the correct position if a grid item is removed after an edit
        _reloadStore: function(grid, record) {
            var scope = this._createEditorScope(grid);
            if (scope.activeRecordPosition !== -1) {
                grid.editingPlugin.cancelEdit();
            }
            grid.store.reload({
                callback: function() {
                    if (scope.activeRecordPosition !== -1) {
                        var newPosition = grid.store.find('_ref', scope.activeRecord.data._ref);
                        if (newPosition === -1) {
                            newPosition = scope.activeRecordPosition;
                        }
                        if (newPosition < grid.store.getCount()) {
                            grid.editingPlugin.startEdit(grid.store.data.items[newPosition], scope.activeColumn);
                        }
                    }
                }
            });
        },

        _createEditorScope: function(grid) {
            var scope = {};
            scope.editor = grid.editingPlugin;
            scope.activeColumn = scope.editor.getActiveColumn();
            scope.activeRecord = scope.editor.getActiveRecord();
            scope.activeRecordPosition = (scope.activeRecord && scope.activeRecord.data) ? grid.store.find('_ref', scope.activeRecord.data._ref) : -1;

            return scope;
        }
    });
})();
Ext.define('CArABU.technicalservices.StoryRollupCustomListSettings',{
    singleton: true,

    storyStartDateField: 'fred',
    storyEndDateField: undefined
});

Ext.define('CArABU.technicalservices.TeamsTemplateColumn', {
    extend: 'Ext.grid.column.Template',
    alias: ['widget.teamstemplatecolumn'],

    align: 'right',

    initComponent: function(){
        var me = this;

        Ext.QuickTips.init();

        me.tpl = new Ext.XTemplate('<tpl><div data-qtip="{[this.getTooltip(values)]}" style="cursor:pointer;text-align:right;">{[this.getTeamsText(values)]}</div></tpl>',{
            getTeamsText: function(values){
                if (values && values.Teams){
                    if (Ext.isArray(values.Teams)){
                        var teams = Ext.Array.unique(values.Teams);
                        return teams.length;
                    }
                }
                return '--';
            },
            getTooltip: function(values){

                if (values && values.Teams && Ext.isArray(values.Teams)){
                    var hash = {};
                    Ext.Array.each(values.Teams, function(t){
                        if (!hash[t]){
                            hash[t] = 0;
                        }
                        hash[t]++;
                    });
                    var tooltip = "";
                    Ext.Object.each(hash, function(team, num){
                        tooltip += Ext.String.format("{0} ({1} leaf stories)<br/>", team, num);
                    });
                    return tooltip;

                }
                return "";

            }

        });
        me.hasCustomRenderer = true;
        me.callParent(arguments);
    },
    defaultRenderer: function(value, meta, record) {
        var data = Ext.apply({}, record.getData()); //, record.getAssociatedData());
        return this.tpl.apply(data);
    }
});

Ext.define("story-rollup-custom-list", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    items: [
        {xtype:'container',itemId:'selector_box'},
        {xtype:'container',itemId:'grid_box'}
    ],

    integrationHeaders : {
        name : "story-rollup-custom-list"
    },

    config: {
        defaultSettings: {
            queryFilter: "",
            tfsLinkField: "c_TFSLink"
        }
    },

    acceptedScheduleStates: ['Accepted'],

    launch: function() {
        this.initializeCompletedScheduleStates("Accepted").then({
            success: this.initializeApp,
            failure: this.showErrorNotification,
            scope: this
        });

    },
    initializeCompletedScheduleStates: function(firstCompletedState){
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: 'UserStory',
            success: function(model) {
                model.getField('ScheduleState').getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        if (success){
                            var scheduleStates = [];
                            Ext.Array.each(records, function(allowedValue) {
                                //each record is an instance of the AllowedAttributeValue model
                                scheduleStates.push(allowedValue.get('StringValue'));
                            });
                            var completedIndex = _.indexOf(scheduleStates,firstCompletedState);
                            deferred.resolve(Ext.Array.slice(scheduleStates,completedIndex))
                        } else {
                            var msg = "Error fetching Schedule State values:  " + operation && operation.error && operation.error.errors.join(",");
                            deferred.reject(msg);
                        }

                    }
                });
            }
        });

        return deferred;
    },
    initializeApp: function(completedScheduleStates){
        this.acceptedScheduleStates = completedScheduleStates;
        this.logger.log('initializeApp', completedScheduleStates);

        this.getSelectorBox().removeAll();

        var cb = this.getSelectorBox().add({
            xtype: 'rallyportfolioitemtypecombobox',
            fieldLabel: "Type"
        });
        cb.on('select', this.updateView, this);
    },
    getSelectorBox: function(){
        return this.down('#selector_box');
    },
    getGridBox: function() {
        return this.down('#grid_box');
    },
    getTFSTeamPrefix: function(){
        return "TFS: ";
    },
    getInitialFilters: function(){
        var query = this.getSetting('queryFilter');
        if (query && query.length > 0){
            var filters = Rally.data.wsapi.Filter.fromQueryString(query);
            return filters;
        }
        return [];
    },
    getTFSLinkField: function(){
        return this.getSetting('tfsLinkField');
    },
    updateView: function(piSelector){
        var piType = piSelector.getRecord() && piSelector.getRecord().get('TypePath');
        this.logger.log('updateView', piType);

        this.childHash = {};
        this.getGridBox().removeAll();

        if (!piType){
            return;
        }

        this.modelNames = [piType];
        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: this.modelNames,
            fetch: [this.getFeatureName(),'ScheduleState','PlanEstimate', this.getTFSLinkField()],
            enableHierarchy: true,
            filters: this.getInitialFilters()
        }).then({
            success: this.buildGridBoard,
            scope: this
        });

    },
    getFeatureName: function(){
        return 'Feature';
    },
    updateAssociatedData: function(store, node, records, success){
        this.logger.log('updateAssociatedData', store, node, records, success);
        var updateableRecords = [],
            featureOids = [],
            featureName = this.getFeatureName(),
            subLevelRecords = [];

        Ext.Array.each(records, function(r){
            if (r.get('PortfolioItem')){
                updateableRecords.push(r);
                if (!Ext.Array.contains(featureOids,r.get('PortfolioItem').ObjectID )){
                    featureOids.push(r.get('PortfolioItem').ObjectID);
                }
            } else if (r.get(featureName)){
                subLevelRecords.push(r);
            }
        });
        this.logger.log('updateAssociatedData', subLevelRecords, updateableRecords, featureOids);

        if (updateableRecords.length > 0){
            Ext.create('CArABU.technicalservices.chunk.Store',{
                storeConfig: {
                    model: 'HierarchicalRequirement',
                    context: { project: null },
                    fetch: ['PlanEstimate','ScheduleState','PortfolioItem','Parent','ObjectID','Project','Name',this.getTFSLinkField()],
                    filters: {
                        property: 'Parent.ObjectID',
                        operator: '>',
                        value: 0
                    }
                },
                chunkProperty: featureName + '.ObjectID',
                chunkValue: featureOids
            }).load().then({
                success: function(children){
                    this.processChildren(updateableRecords, children);
                },
                failure: this.showErrorNotification,
                scope: this
            });
        }

        if (subLevelRecords.length > 0){
           this.updateAdditionalFields(subLevelRecords, this.childHash || {});
        }

    },
    updateAdditionalFields: function(records, childHash){
        this.logger.log('updateAdditionalFields',records, childHash);
        for (var i=0; i< records.length; i++){
            var r = records[i],
                totals = this.getChildTotals(r, childHash);

            var percentDoneByStoryCount = totals.totalCount > 0 ? totals.totalAcceptedCount/totals.totalCount : 0,
                percentDoneByPlanEstimate = totals.totalPlanEstimate > 0 ? totals.totalAcceptedPlanEstimate/totals.totalPlanEstimate : 0;

            this.logger.log('updateAdditionalFields results', percentDoneByPlanEstimate,percentDoneByStoryCount,totals.projects);

            r.set('PercentDoneByStoryCount',percentDoneByStoryCount);
            r.set('PercentDoneByStoryPlanEstimate',percentDoneByPlanEstimate);
            r.set('Teams', totals.projects);
        }

    },
    processChildren: function(topLevelStoryRecords, childRecords){
        this.logger.log('processChildren', childRecords)
        if (!childRecords || childRecords.length == 0){
            this.updateAdditionalFields(topLevelStoryRecords,this.childHash || {});
            return;
        }

        var childHash = this.childHash || {};
        for (var i=0; i<childRecords.length; i++){
            var child = childRecords[i].getData(),
                parent = (child.PortfolioItem && child.PortfolioItem.ObjectID) ||
                            (child.Parent && child.Parent.ObjectID) || null;

            if (parent){
                if (!childHash[parent]){
                    childHash[parent] = [];
                }
                childHash[parent].push(child);
            }
        }
        this.childHash = childHash;

        this.logger.log('processChildren', childHash, topLevelStoryRecords);

        this.updateAdditionalFields(topLevelStoryRecords,childHash);

    },
    getChildTotals: function(record, childHash){
        this.logger.log('getChildTotals', record, childHash);
        var oid = record.ObjectID || record.get('ObjectID');
        var acceptedScheduleStates = this.acceptedScheduleStates;
        var children = childHash[oid] || [],
            totalPlanEstimate = 0,
            totalAcceptedPlanEstimate = 0,
            totalCount = 0,
            totalAcceptedCount = 0,
            projects = [],
            tfsLinkField = this.getTFSLinkField(),
            tfsPrefix = this.getTFSTeamPrefix();

        if (children.length > 0) {
            Ext.Array.each(children, function (c) {
                var totals = {};
                if (!c.ObjectID){
                    c = c.getData();
                }

                if (childHash[c.ObjectID]) {
                    totals = this.getChildTotals(c, childHash, acceptedScheduleStates);
                } else {
                    var isAccepted = Ext.Array.contains(acceptedScheduleStates, c.ScheduleState),
                        acceptedPlanEstimate = isAccepted && c.PlanEstimate || 0,
                        acceptedTotal = isAccepted && 1 || 0,
                        isTFS = c[tfsLinkField],
                        projectName = c.Project && c.Project.Name;

                    if (isTFS){
                        projectName = tfsPrefix + projectName;
                    }
                    totals = {
                        totalPlanEstimate: c.PlanEstimate || 0,
                        totalAcceptedPlanEstimate: acceptedPlanEstimate,
                        totalCount: 1,
                        totalAcceptedCount: acceptedTotal,
                        projects: [projectName]
                    };
                }
                totalPlanEstimate += totals.totalPlanEstimate;
                totalAcceptedPlanEstimate += totals.totalAcceptedPlanEstimate;
                totalCount += totals.totalCount;
                totalAcceptedCount += totals.totalAcceptedCount;
                projects = projects.concat(totals.projects);

            }, this);
        } else {
            var recordData = record.ObjectID ? record : record.getData(),
                isAccepted = Ext.Array.contains(acceptedScheduleStates, recordData.ScheduleState),
                acceptedPlanEstimate = isAccepted && recordData.PlanEstimate || 0,
                acceptedTotal = isAccepted && 1 || 0;

            totalPlanEstimate = recordData.PlanEstimate || 0;
            totalAcceptedPlanEstimate = acceptedPlanEstimate;
            totalCount = 1;
            totalAcceptedCount = acceptedTotal;
            projects = [recordData.Project && recordData.Project.Name]
        }


        return {
            totalPlanEstimate: totalPlanEstimate,
            totalAcceptedPlanEstimate: totalAcceptedPlanEstimate,
            totalCount: totalCount,
            totalAcceptedCount: totalAcceptedCount,
            projects: projects
        };
    },
    showErrorNotification: function(msg){
        Rally.ui.notify.Notifier.showError({message: msg});
    },
    buildGridBoard: function(store){
        var modelNames = this.modelNames,
            context = this.getContext();

        this.getGridBox().removeAll();
        store.on('load', this.updateAssociatedData, this);
        this.getGridBox().add({
            xtype: 'rallygridboard',
            context: context,
            modelNames: modelNames,
            toggleState: 'grid',
            stateful: false,
            stateId: 'fred2',
            plugins: [
                'rallygridboardaddnew',
                {
                    ptype: 'rallygridboardfieldpicker',
                    headerPosition: 'left',
                    modelNames: modelNames,
                    stateful: true,
                    stateId: context.getScopedStateId('columns4')
                },{
                    ptype: 'rallygridboardinlinefiltercontrol',
                    inlineFilterButtonConfig: {
                        stateful: true,
                        stateId: context.getScopedStateId('filters'),
                        modelNames: modelNames,
                        inlineFilterPanelConfig: {
                            quickFilterPanelConfig: {
                                defaultFields: [
                                    'ArtifactSearch',
                                    'Owner',
                                    'ModelType'
                                ]
                            }
                        }
                    }
                }, {
                    ptype: 'rallygridboardactionsmenu',
                    menuItems: [
                        {
                            text: 'Export...',
                            handler: function() {
                                window.location = Rally.ui.gridboard.Export.buildCsvExportUrl(
                                    this.down('rallygridboard').getGridOrBoard());
                            },
                            scope: this
                        }
                    ],
                    buttonConfig: {
                        iconCls: 'icon-export'
                    }
                }
            ],
            gridConfig: {
                store: store,
                storeConfig: {
                    filters: this.getInitialFilters()
                },
                columnCfgs: this.getDefaultColumns(),
                derivedColumns: this.getAdditionalColumns()
            },
            height: this.getHeight()
        });
    },
    getDefaultColumns: function(){
        var cols = [
            'Name',
            'PercentDoneByStoryPlanEstimate',
            'PercentDoneByStoryCount',
            'State',
            'Owner'
        ].concat(this.getAdditionalColumns());
        this.logger.log('getDefaultColumns', cols);
        return cols;
    },
    getAdditionalColumns: function(){
        return [{
            xtype: 'teamstemplatecolumn',
            text: 'Teams'
        }];
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        // Ext.apply(this, settings);
        this.launch();
    },
    getSettingsFields: function(){
        return [{
            xtype: 'rallyfieldcombobox',
            model: 'hierarchicalrequirement',
            name: 'tfsLinkField',
            fieldLabel: "TFS Link Field",
            labelAlign: 'right',
            labelWidth: 100,
            _isNotHidden: function(field){

                if (!field.readOnly && field.attributeDefinition && (field.attributeDefinition.AttributeType === 'STRING' ||
                        field.attributeDefinition.AttributeType === 'TEXT')){
                    return true;
                }
                return false;
            }
        },{
            xtype: 'textarea',
            fieldLabel: 'Query',
            name: 'queryFilter',
            anchor: '100%',
            cls: 'query-field',
            margin: '0 70 0 0',
            labelAlign: 'right',
            labelWidth: 100,
            plugins: [
                {
                    ptype: 'rallyhelpfield',
                    helpId: 194
                },
                'rallyfieldvalidationui'
            ],
            validateOnBlur: false,
            validateOnChange: false,
            validator: function(value) {
                try {
                    if (value) {
                        Rally.data.wsapi.Filter.fromQueryString(value);
                    }
                    return true;
                } catch (e) {
                    return e.message;
                }
            }
        }];
    }
});

            
               Rally.launchApp('story-rollup-custom-list', {
                   name: 'Story Rollup Custom List'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>